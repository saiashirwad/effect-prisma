// This file was generated by effect-prisma, do not edit manually.

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback: (cause: unknown) => Err,
) => Effect.Effect<A, Err>;

export interface OrganizationMemberRepository {
  findFirst: <T extends Prisma.OrganizationMemberFindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  findUnique: <T extends Prisma.OrganizationMemberFindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  findMany: <T extends Prisma.OrganizationMemberFindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>[], E>;

  create: <T extends Prisma.OrganizationMemberCreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  createMany: <T extends Prisma.OrganizationMemberCreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.OrganizationMemberCreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>[], E>;

  update: <T extends Prisma.OrganizationMemberUpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  updateMany: <T extends Prisma.OrganizationMemberUpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.OrganizationMemberUpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  delete: <T extends Prisma.OrganizationMemberDeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.OrganizationMemberGetPayload<T>, E>;

  deleteMany: <T extends Prisma.OrganizationMemberDeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.OrganizationMemberCountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}

export function createOrganizationMemberRepository(exec: Exec): OrganizationMemberRepository {
  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.organizationMember.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "OrganizationMember", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };
}
