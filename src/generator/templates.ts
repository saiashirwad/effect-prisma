import type { DMMF } from "@prisma/generator-helper";
import {
  toCamelCase,
  toSnakeCase,
  mapPrismaTypeToEffectSchema,
  type ScalarMappings,
} from "./utils.js";

const HEADER = `// This file was generated by effect-prisma, do not edit manually.
`;

export function generateErrorsFile(
  models: readonly DMMF.Model[],
  runtimePath: string
): string {
  const modelNames = models.map((m) => `"${m.name}"`).join(", ");

  return `${HEADER}
import { Schema } from "effect";
import {
  PrismaNotFoundError as BasePrismaNotFoundError,
  PrismaCreateError as BasePrismaCreateError,
  PrismaUpdateError as BasePrismaUpdateError,
  PrismaDeleteError as BasePrismaDeleteError,
  PrismaQueryError as BasePrismaQueryError,
  parsePrismaErrorKind,
} from "${runtimePath}";

export const TableName = Schema.Literal(${modelNames});
export type TableName = typeof TableName.Type;

export {
  BasePrismaNotFoundError as PrismaNotFoundError,
  BasePrismaCreateError as PrismaCreateError,
  BasePrismaUpdateError as PrismaUpdateError,
  BasePrismaDeleteError as PrismaDeleteError,
  BasePrismaQueryError as PrismaQueryError,
  parsePrismaErrorKind,
};
`;
}

export function generateRepositoryInterface(modelName: string): string {
  return `export interface ${modelName}Repository {
  findFirst: <T extends Prisma.${modelName}FindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  findUnique: <T extends Prisma.${modelName}FindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  findMany: <T extends Prisma.${modelName}FindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>[], E>;

  create: <T extends Prisma.${modelName}CreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  createMany: <T extends Prisma.${modelName}CreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.${modelName}CreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>[], E>;

  update: <T extends Prisma.${modelName}UpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  updateMany: <T extends Prisma.${modelName}UpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.${modelName}UpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  delete: <T extends Prisma.${modelName}DeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.${modelName}GetPayload<T>, E>;

  deleteMany: <T extends Prisma.${modelName}DeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.${modelName}CountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}`;
}

export function generateRepositoryMethods(modelName: string): string {
  const modelNameCamel = toCamelCase(modelName);

  return `  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.${modelNameCamel}.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "${modelName}", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };`;
}

export function generateRepositoryFile(
  model: DMMF.Model,
  runtimePath: string
): string {
  const modelName = model.name;

  return `${HEADER}
/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  parsePrismaErrorKind,
} from "${runtimePath}";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback: (cause: unknown) => Err,
) => Effect.Effect<A, Err>;

${generateRepositoryInterface(modelName)}

export function create${modelName}Repository(exec: Exec): ${modelName}Repository {
${generateRepositoryMethods(modelName)}
}
`;
}

export function generateIndexFile(
  models: readonly DMMF.Model[],
  runtimePath: string
): string {
  const sortedModels = [...models].sort((a, b) =>
    toSnakeCase(a.name).localeCompare(toSnakeCase(b.name))
  );

  const imports = sortedModels
    .map((model) => {
      const fileName = toSnakeCase(model.name);
      return `import { create${model.name}Repository, type ${model.name}Repository } from "./${fileName}.js";`;
    })
    .join("\n");

  const repositoriesInterface = sortedModels
    .map((model) => `  ${toSnakeCase(model.name)}: ${model.name}Repository;`)
    .join("\n");

  const returnObject = sortedModels
    .map((model) => `      ${toSnakeCase(model.name)}: create${model.name}Repository(exec),`)
    .join("\n");

  const helperReturnObject = sortedModels
    .map((model) => `    ${toSnakeCase(model.name)}: create${model.name}Repository(exec),`)
    .join("\n");

  return `${HEADER}
import type { PrismaClient } from "@prisma/client";
import { Effect } from "effect";

import { Prisma, createExec } from "${runtimePath}";

${imports}

export interface DBRepositories {
${repositoriesInterface}
}

export function createDBRepositories(client: PrismaClient): DBRepositories {
  const exec = createExec(client);
  return {
${helperReturnObject}
  };
}

export class DB extends Effect.Service<DB>()("effect-prisma/DB", {
  effect: Effect.gen(function* () {
    const client = yield* Prisma;
    const exec = createExec(client);

    return {
${returnObject}
    } as DBRepositories;
  }),
}) {}

export * from "./errors.js";
`;
}

export function generateEnumSchemas(
  enums: readonly DMMF.DatamodelEnum[]
): string {
  const enumSchemas = enums
    .map((enumType) => {
      const values = enumType.values.map((v) => `"${v.name}"`).join(", ");
      return `export const ${enumType.name}Schema = Schema.Literal(${values});
export type ${enumType.name} = typeof ${enumType.name}Schema.Type;
`;
    })
    .join("\n");

  return `${HEADER}
import { Schema } from "effect";

${enumSchemas}
`;
}

export function generateModelSchema(
  model: DMMF.Model,
  runtimePath: string,
  scalarMappings: ScalarMappings = {}
): string {
  const modelName = model.name;
  const scalarFields = model.fields.filter((f) => f.kind !== "object");

  const scalarSchemaEntries = scalarFields
    .map((field) => {
      const schemaType = mapPrismaTypeToEffectSchema(field, scalarMappings);
      if (!schemaType) return null;
      return { name: field.name, schemaType };
    })
    .filter(
      (entry): entry is { name: string; schemaType: string } => entry !== null
    );

  const fieldSchemas = scalarSchemaEntries
    .map((entry) => `  ${entry.name}: ${entry.schemaType},`)
    .join("\n");

  const usedEnums = new Set(
    scalarFields.filter((f) => f.kind === "enum").map((f) => f.type)
  );

  const needsPrismaDecimal = scalarSchemaEntries.some((entry) =>
    /\bPrismaDecimal\b/.test(entry.schemaType)
  );

  const enumImports =
    usedEnums.size > 0
      ? `import { ${Array.from(usedEnums)
          .map((e) => `${e}Schema`)
          .join(", ")} } from "./enums.js";\n`
      : "";

  const decimalImport = needsPrismaDecimal
    ? `import { PrismaDecimal } from "${runtimePath}";\n`
    : "";

  return `${HEADER}
import { Schema } from "effect";
${decimalImport}${enumImports}
export const ${modelName}Schema = Schema.Struct({
${fieldSchemas}
});

export type ${modelName} = typeof ${modelName}Schema.Type;
`;
}

export function generateSchemasIndex(models: readonly DMMF.Model[]): string {
  const sortedModels = [...models].sort((a, b) =>
    toSnakeCase(a.name).localeCompare(toSnakeCase(b.name))
  );

  const exports = sortedModels
    .map((model) => {
      const fileName = toSnakeCase(model.name);
      return `export * from "./${fileName}.js";`;
    })
    .join("\n");

  return `${HEADER}
export * from "./enums.js";
${exports}
`;
}
