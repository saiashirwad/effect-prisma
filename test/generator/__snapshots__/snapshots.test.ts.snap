// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`Generated Code Snapshots Repository File User repository matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  PrismaError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback?: (cause: unknown) => Err,
) => Effect.Effect<A, Err | PrismaError>;

export interface UserRepository {
  findFirst: <T extends Prisma.UserFindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  findUnique: <T extends Prisma.UserFindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  findMany: <T extends Prisma.UserFindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>[], E>;

  create: <T extends Prisma.UserCreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  createMany: <T extends Prisma.UserCreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.UserCreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>[], E>;

  update: <T extends Prisma.UserUpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  updateMany: <T extends Prisma.UserUpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.UserUpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  delete: <T extends Prisma.UserDeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  deleteMany: <T extends Prisma.UserDeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.UserCountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}

export function createUserRepository(exec: Exec): UserRepository {
  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.user.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.user.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.user.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.user.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.user.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.user.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.user.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.user.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.user.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.user.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.user.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.user.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };
}
"
`;

exports[`Generated Code Snapshots Repository File Post repository matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  PrismaError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback?: (cause: unknown) => Err,
) => Effect.Effect<A, Err | PrismaError>;

export interface PostRepository {
  findFirst: <T extends Prisma.PostFindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  findUnique: <T extends Prisma.PostFindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  findMany: <T extends Prisma.PostFindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>[], E>;

  create: <T extends Prisma.PostCreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  createMany: <T extends Prisma.PostCreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.PostCreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>[], E>;

  update: <T extends Prisma.PostUpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  updateMany: <T extends Prisma.PostUpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.PostUpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  delete: <T extends Prisma.PostDeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.PostGetPayload<T>, E>;

  deleteMany: <T extends Prisma.PostDeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.PostCountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}

export function createPostRepository(exec: Exec): PostRepository {
  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.post.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.post.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.post.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.post.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.post.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.post.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.post.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.post.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.post.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.post.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.post.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.post.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "Post", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };
}
"
`;

exports[`Generated Code Snapshots Repository File Product repository matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  PrismaError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback?: (cause: unknown) => Err,
) => Effect.Effect<A, Err | PrismaError>;

export interface ProductRepository {
  findFirst: <T extends Prisma.ProductFindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  findUnique: <T extends Prisma.ProductFindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  findMany: <T extends Prisma.ProductFindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>[], E>;

  create: <T extends Prisma.ProductCreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  createMany: <T extends Prisma.ProductCreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.ProductCreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>[], E>;

  update: <T extends Prisma.ProductUpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  updateMany: <T extends Prisma.ProductUpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.ProductUpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  delete: <T extends Prisma.ProductDeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.ProductGetPayload<T>, E>;

  deleteMany: <T extends Prisma.ProductDeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.ProductCountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}

export function createProductRepository(exec: Exec): ProductRepository {
  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.product.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.product.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.product.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.product.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.product.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.product.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.product.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.product.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.product.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.product.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.product.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.product.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "Product", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };
}
"
`;

exports[`Generated Code Snapshots Repository File Repository with custom runtime path matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

/* eslint-disable @typescript-eslint/no-explicit-any */
import type { Prisma, PrismaClient } from "@prisma/client";
import { Effect, Option } from "effect";

import {
  PrismaNotFoundError,
  PrismaCreateError,
  PrismaUpdateError,
  PrismaDeleteError,
  PrismaQueryError,
  PrismaError,
  parsePrismaErrorKind,
} from "@/lib/runtime";

type Exec = <A, Err extends Error>(
  f: (db: PrismaClient) => Promise<A>,
  errCallback?: (cause: unknown) => Err,
) => Effect.Effect<A, Err | PrismaError>;

export interface UserRepository {
  findFirst: <T extends Prisma.UserFindFirstArgs, E = PrismaNotFoundError>(
    args?: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  findUnique: <T extends Prisma.UserFindUniqueArgs, E = PrismaNotFoundError>(
    args: T,
    mapError?: (e: PrismaNotFoundError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  findMany: <T extends Prisma.UserFindManyArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>[], E>;

  create: <T extends Prisma.UserCreateArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  createMany: <T extends Prisma.UserCreateManyArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  createManyAndReturn: <T extends Prisma.UserCreateManyAndReturnArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>[], E>;

  update: <T extends Prisma.UserUpdateArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  updateMany: <T extends Prisma.UserUpdateManyArgs, E = PrismaUpdateError>(
    args: T,
    mapError?: (e: PrismaUpdateError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  upsert: <T extends Prisma.UserUpsertArgs, E = PrismaCreateError>(
    args: T,
    mapError?: (e: PrismaCreateError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  delete: <T extends Prisma.UserDeleteArgs, E = PrismaDeleteError>(
    args: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.UserGetPayload<T>, E>;

  deleteMany: <T extends Prisma.UserDeleteManyArgs, E = PrismaDeleteError>(
    args?: T,
    mapError?: (e: PrismaDeleteError) => E,
  ) => Effect.Effect<Prisma.BatchPayload, E>;

  count: <T extends Prisma.UserCountArgs, E = PrismaQueryError>(
    args?: T,
    mapError?: (e: PrismaQueryError) => E,
  ) => Effect.Effect<number, E>;
}

export function createUserRepository(exec: Exec): UserRepository {
  return {
    findFirst: (args, mapError) => {
      const effect = exec(
        db => db.user.findFirstOrThrow(args ?? ({} as any)),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findUnique: (args, mapError) => {
      const effect = exec(
        db => db.user.findUniqueOrThrow(args),
        cause => new PrismaNotFoundError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    findMany: (args, mapError) => {
      const effect = exec(
        db => db.user.findMany(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    create: (args, mapError) => {
      const effect = exec(
        db => db.user.create(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createMany: (args, mapError) => {
      const effect = exec(
        db => db.user.createMany(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    createManyAndReturn: (args, mapError) => {
      const effect = exec(
        db => db.user.createManyAndReturn(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    update: (args, mapError) => {
      const effect = exec(
        db => db.user.update(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    updateMany: (args, mapError) => {
      const effect = exec(
        db => db.user.updateMany(args),
        cause => new PrismaUpdateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: args.where as any, data: args.data as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    upsert: (args, mapError) => {
      const effect = exec(
        db => db.user.upsert(args),
        cause => new PrismaCreateError({ kind: parsePrismaErrorKind(cause), cause, table: "User", data: args.create as any }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    delete: (args, mapError) => {
      const effect = exec(
        db => db.user.delete(args),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.some(args.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    deleteMany: (args, mapError) => {
      const effect = exec(
        db => db.user.deleteMany(args ?? ({} as any)),
        cause => new PrismaDeleteError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },

    count: (args, mapError) => {
      const effect = exec(
        db => db.user.count(args ?? ({} as any)),
        cause => new PrismaQueryError({ kind: parsePrismaErrorKind(cause), cause, table: "User", where: Option.fromNullable(args?.where) }),
      ) as any;
      return mapError ? Effect.mapError(effect, mapError) : effect;
    },
  };
}
"
`;

exports[`Generated Code Snapshots Errors File Single model errors file matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";
import {
  PrismaNotFoundError as BasePrismaNotFoundError,
  PrismaCreateError as BasePrismaCreateError,
  PrismaUpdateError as BasePrismaUpdateError,
  PrismaDeleteError as BasePrismaDeleteError,
  PrismaQueryError as BasePrismaQueryError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

export const TableName = Schema.Literal("User");
export type TableName = typeof TableName.Type;

export {
  BasePrismaNotFoundError as PrismaNotFoundError,
  BasePrismaCreateError as PrismaCreateError,
  BasePrismaUpdateError as PrismaUpdateError,
  BasePrismaDeleteError as PrismaDeleteError,
  BasePrismaQueryError as PrismaQueryError,
  parsePrismaErrorKind,
};
"
`;

exports[`Generated Code Snapshots Errors File Multiple models errors file matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";
import {
  PrismaNotFoundError as BasePrismaNotFoundError,
  PrismaCreateError as BasePrismaCreateError,
  PrismaUpdateError as BasePrismaUpdateError,
  PrismaDeleteError as BasePrismaDeleteError,
  PrismaQueryError as BasePrismaQueryError,
  parsePrismaErrorKind,
} from "effect-prisma/runtime";

export const TableName = Schema.Literal("User", "Post", "Product");
export type TableName = typeof TableName.Type;

export {
  BasePrismaNotFoundError as PrismaNotFoundError,
  BasePrismaCreateError as PrismaCreateError,
  BasePrismaUpdateError as PrismaUpdateError,
  BasePrismaDeleteError as PrismaDeleteError,
  BasePrismaQueryError as PrismaQueryError,
  parsePrismaErrorKind,
};
"
`;

exports[`Generated Code Snapshots Index File Single model index file matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import type { PrismaClient } from "@prisma/client";
import { Effect } from "effect";

import { PrismaService, PrismaServiceLive, createExec } from "effect-prisma/runtime";

import { createUserRepository, type UserRepository } from "./user.js";

export interface DBRepositories {
  user: UserRepository;
}

export function createDBRepositories(client: PrismaClient): DBRepositories {
  const exec = createExec(client);
  return {
    user: createUserRepository(exec),
  };
}

export class DB extends Effect.Service<DB>()("effect-prisma/DB", {
  effect: Effect.gen(function* () {
    const prismaService = yield* PrismaService;
    const exec = prismaService.exec;

    return {
      user: createUserRepository(exec),
    } as DBRepositories;
  }),
  dependencies: [PrismaServiceLive],
}) {}

export * from "./errors.js";
"
`;

exports[`Generated Code Snapshots Index File Multiple models index file matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import type { PrismaClient } from "@prisma/client";
import { Effect } from "effect";

import { PrismaService, PrismaServiceLive, createExec } from "effect-prisma/runtime";

import { createPostRepository, type PostRepository } from "./post.js";
import { createProductRepository, type ProductRepository } from "./product.js";
import { createUserRepository, type UserRepository } from "./user.js";

export interface DBRepositories {
  post: PostRepository;
  product: ProductRepository;
  user: UserRepository;
}

export function createDBRepositories(client: PrismaClient): DBRepositories {
  const exec = createExec(client);
  return {
    post: createPostRepository(exec),
    product: createProductRepository(exec),
    user: createUserRepository(exec),
  };
}

export class DB extends Effect.Service<DB>()("effect-prisma/DB", {
  effect: Effect.gen(function* () {
    const prismaService = yield* PrismaService;
    const exec = prismaService.exec;

    return {
      post: createPostRepository(exec),
      product: createProductRepository(exec),
      user: createUserRepository(exec),
    } as DBRepositories;
  }),
  dependencies: [PrismaServiceLive],
}) {}

export * from "./errors.js";
"
`;

exports[`Generated Code Snapshots Enum Schemas Single enum schema matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";

export const UserRoleSchema = Schema.Literal("ADMIN", "USER", "GUEST");
export type UserRole = typeof UserRoleSchema.Type;

"
`;

exports[`Generated Code Snapshots Enum Schemas Multiple enum schemas match snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";

export const UserRoleSchema = Schema.Literal("ADMIN", "USER", "GUEST");
export type UserRole = typeof UserRoleSchema.Type;

export const StatusSchema = Schema.Literal("PENDING", "ACTIVE", "INACTIVE");
export type Status = typeof StatusSchema.Type;

"
`;

exports[`Generated Code Snapshots Enum Schemas Empty enums match snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";


"
`;

exports[`Generated Code Snapshots Model Schema User schema matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";
import { UserRoleSchema } from "./enums.js";

export const UserSchema = Schema.Struct({
  id: Schema.Int,
  email: Schema.String,
  name: Schema.NullOr(Schema.String),
  createdAt: Schema.Date,
  role: UserRoleSchema,
});

export type User = typeof UserSchema.Type;
"
`;

exports[`Generated Code Snapshots Model Schema Post schema matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";

export const PostSchema = Schema.Struct({
  id: Schema.Int,
  title: Schema.String,
  content: Schema.NullOr(Schema.String),
  published: Schema.Boolean,
  views: Schema.BigIntFromSelf,
  createdAt: Schema.Date,
  authorId: Schema.Int,
});

export type Post = typeof PostSchema.Type;
"
`;

exports[`Generated Code Snapshots Model Schema Product schema with Decimal matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

import { Schema } from "effect";
import { PrismaDecimal } from "effect-prisma/runtime";

export const ProductSchema = Schema.Struct({
  id: Schema.Int,
  name: Schema.String,
  price: PrismaDecimal,
  metadata: Schema.NullOr(Schema.Unknown),
  tags: Schema.Array(Schema.String),
});

export type Product = typeof ProductSchema.Type;
"
`;

exports[`Generated Code Snapshots Schemas Index Single model schemas index matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

export * from "./enums.js";
export * from "./user.js";
"
`;

exports[`Generated Code Snapshots Schemas Index Multiple models schemas index matches snapshot 1`] = `
"// This file was generated by effect-prisma, do not edit manually.

export * from "./enums.js";
export * from "./post.js";
export * from "./product.js";
export * from "./user.js";
"
`;
