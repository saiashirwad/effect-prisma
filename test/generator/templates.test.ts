import { describe, expect, test } from "bun:test";
import {
  generateErrorsFile,
  generateRepositoryInterface,
  generateRepositoryMethods,
  generateRepositoryFile,
  generateIndexFile,
  generateEnumSchemas,
  generateModelSchema,
  generateSchemasIndex,
} from "../../src/generator/templates.js";
import {
  createMockModel,
  createMockField,
  createMockEnum,
  mockUserModel,
  mockPostModel,
  mockProductModel,
  mockUserRoleEnum,
  mockStatusEnum,
} from "../fixtures/dmmf.js";

describe("generateErrorsFile", () => {
  test("contains header comment", () => {
    const result = generateErrorsFile([mockUserModel], "effect-prisma/runtime");
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("contains model name in Literal schema for single model", () => {
    const result = generateErrorsFile([mockUserModel], "effect-prisma/runtime");
    expect(result).toContain('Schema.Literal("User")');
  });

  test("contains all model names for multiple models", () => {
    const result = generateErrorsFile([mockUserModel, mockPostModel], "effect-prisma/runtime");
    expect(result).toContain('"User"');
    expect(result).toContain('"Post"');
  });

  test("uses custom runtimePath for imports", () => {
    const result = generateErrorsFile([mockUserModel], "@/custom/runtime");
    expect(result).toContain('from "@/custom/runtime"');
  });

  test("re-exports all error types", () => {
    const result = generateErrorsFile([mockUserModel], "effect-prisma/runtime");
    expect(result).toContain("PrismaNotFoundError");
    expect(result).toContain("PrismaCreateError");
    expect(result).toContain("PrismaUpdateError");
    expect(result).toContain("PrismaDeleteError");
    expect(result).toContain("PrismaQueryError");
  });

  test("exports parsePrismaErrorKind", () => {
    const result = generateErrorsFile([mockUserModel], "effect-prisma/runtime");
    expect(result).toContain("parsePrismaErrorKind");
  });

  test("exports TableName schema", () => {
    const result = generateErrorsFile([mockUserModel], "effect-prisma/runtime");
    expect(result).toContain("export const TableName");
    expect(result).toContain("export type TableName");
  });
});

describe("generateRepositoryInterface", () => {
  const result = generateRepositoryInterface("User");

  test("creates interface with correct name", () => {
    expect(result).toContain("export interface UserRepository");
  });

  test("includes findFirst method", () => {
    expect(result).toContain("findFirst:");
    expect(result).toContain("Prisma.UserFindFirstArgs");
  });

  test("includes findUnique method", () => {
    expect(result).toContain("findUnique:");
    expect(result).toContain("Prisma.UserFindUniqueArgs");
  });

  test("includes findMany method", () => {
    expect(result).toContain("findMany:");
    expect(result).toContain("Prisma.UserFindManyArgs");
  });

  test("includes create method", () => {
    expect(result).toContain("create:");
    expect(result).toContain("Prisma.UserCreateArgs");
  });

  test("includes createMany method", () => {
    expect(result).toContain("createMany:");
    expect(result).toContain("Prisma.UserCreateManyArgs");
    expect(result).toContain("Prisma.BatchPayload");
  });

  test("includes createManyAndReturn method", () => {
    expect(result).toContain("createManyAndReturn:");
    expect(result).toContain("Prisma.UserCreateManyAndReturnArgs");
  });

  test("includes update method", () => {
    expect(result).toContain("update:");
    expect(result).toContain("Prisma.UserUpdateArgs");
  });

  test("includes updateMany method", () => {
    expect(result).toContain("updateMany:");
    expect(result).toContain("Prisma.UserUpdateManyArgs");
  });

  test("includes upsert method", () => {
    expect(result).toContain("upsert:");
    expect(result).toContain("Prisma.UserUpsertArgs");
  });

  test("includes delete method", () => {
    expect(result).toContain("delete:");
    expect(result).toContain("Prisma.UserDeleteArgs");
  });

  test("includes deleteMany method", () => {
    expect(result).toContain("deleteMany:");
    expect(result).toContain("Prisma.UserDeleteManyArgs");
  });

  test("includes count method with number return type", () => {
    expect(result).toContain("count:");
    expect(result).toContain("Effect.Effect<number");
  });

  test("all methods have mapError parameter", () => {
    expect(result).toMatch(/findFirst:.*mapError\?/s);
    expect(result).toMatch(/findUnique:.*mapError\?/s);
    expect(result).toMatch(/create:.*mapError\?/s);
    expect(result).toMatch(/update:.*mapError\?/s);
    expect(result).toMatch(/delete:.*mapError\?/s);
  });
});

describe("generateRepositoryMethods", () => {
  const result = generateRepositoryMethods("User");

  test("uses camelCase for db access", () => {
    expect(result).toContain("db.user.");
  });

  test("findFirst uses findFirstOrThrow", () => {
    expect(result).toContain("db.user.findFirstOrThrow");
  });

  test("findUnique uses findUniqueOrThrow", () => {
    expect(result).toContain("db.user.findUniqueOrThrow");
  });

  test("findMany uses findMany", () => {
    expect(result).toContain("db.user.findMany");
  });

  test("includes table name in error construction", () => {
    expect(result).toContain('table: "User"');
  });

  test("calls parsePrismaErrorKind for error kind", () => {
    expect(result).toContain("parsePrismaErrorKind(cause)");
  });

  test("handles mapError conditionally", () => {
    expect(result).toContain("mapError ? Effect.mapError(effect, mapError) : effect");
  });

  test("handles empty args with fallback", () => {
    expect(result).toContain("args ?? ({} as any)");
  });
});

describe("generateRepositoryFile", () => {
  const result = generateRepositoryFile(mockUserModel, "effect-prisma/runtime");

  test("contains header comment", () => {
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("contains eslint disable comment", () => {
    expect(result).toContain("@typescript-eslint/no-explicit-any");
  });

  test("imports Prisma types", () => {
    expect(result).toContain('import type { Prisma, PrismaClient }');
  });

  test("imports Effect and Option", () => {
    expect(result).toContain('import { Effect, Option } from "effect"');
  });

  test("imports error types from runtimePath", () => {
    expect(result).toContain("PrismaNotFoundError");
    expect(result).toContain("PrismaCreateError");
    expect(result).toContain("PrismaUpdateError");
    expect(result).toContain("PrismaDeleteError");
    expect(result).toContain("PrismaQueryError");
    expect(result).toContain('from "effect-prisma/runtime"');
  });

  test("defines Exec type", () => {
    expect(result).toContain("type Exec = <A, Err extends Error>");
  });

  test("contains repository interface", () => {
    expect(result).toContain("export interface UserRepository");
  });

  test("contains factory function", () => {
    expect(result).toContain("export function createUserRepository");
  });

  test("uses custom runtimePath", () => {
    const customResult = generateRepositoryFile(mockUserModel, "@/runtime");
    expect(customResult).toContain('from "@/runtime"');
  });
});

describe("generateIndexFile", () => {
  const result = generateIndexFile([mockUserModel, mockPostModel], "effect-prisma/runtime");

  test("contains header comment", () => {
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("imports are sorted alphabetically by snake_case", () => {
    const importOrder = result.indexOf("./post.js");
    const importOrder2 = result.indexOf("./user.js");
    expect(importOrder).toBeLessThan(importOrder2);
  });

  test("imports all models", () => {
    expect(result).toContain('from "./user.js"');
    expect(result).toContain('from "./post.js"');
  });

  test("defines DBRepositories interface", () => {
    expect(result).toContain("export interface DBRepositories");
    expect(result).toContain("user: UserRepository");
    expect(result).toContain("post: PostRepository");
  });

  test("defines createDBRepositories function", () => {
    expect(result).toContain("export function createDBRepositories");
    expect(result).toContain("client: PrismaClient");
  });

  test("defines DB Effect.Service class", () => {
    expect(result).toContain('export class DB extends Effect.Service<DB>()("effect-prisma/DB"');
  });

  test("imports Prisma and createExec from runtimePath", () => {
    expect(result).toContain("import { Prisma, createExec }");
    expect(result).toContain('from "effect-prisma/runtime"');
  });

  test("re-exports errors", () => {
    expect(result).toContain('export * from "./errors.js"');
  });
});

describe("generateEnumSchemas", () => {
  test("contains header comment", () => {
    const result = generateEnumSchemas([mockUserRoleEnum]);
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("imports Schema from effect", () => {
    const result = generateEnumSchemas([mockUserRoleEnum]);
    expect(result).toContain('import { Schema } from "effect"');
  });

  test("generates Schema.Literal for single enum", () => {
    const result = generateEnumSchemas([mockUserRoleEnum]);
    expect(result).toContain('export const UserRoleSchema = Schema.Literal("ADMIN", "USER", "GUEST")');
  });

  test("generates type export for enum", () => {
    const result = generateEnumSchemas([mockUserRoleEnum]);
    expect(result).toContain("export type UserRole = typeof UserRoleSchema.Type");
  });

  test("generates multiple enums", () => {
    const result = generateEnumSchemas([mockUserRoleEnum, mockStatusEnum]);
    expect(result).toContain("UserRoleSchema");
    expect(result).toContain("StatusSchema");
  });

  test("handles empty enums array", () => {
    const result = generateEnumSchemas([]);
    expect(result).toContain('import { Schema } from "effect"');
    expect(result).not.toContain("Schema.Literal");
  });
});

describe("generateModelSchema", () => {
  test("contains header comment", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("imports Schema from effect", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain('import { Schema } from "effect"');
  });

  test("creates Schema.Struct for model", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain("export const UserSchema = Schema.Struct({");
  });

  test("exports type for model", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain("export type User = typeof UserSchema.Type");
  });

  test("excludes object/relation fields", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).not.toContain("posts:");
  });

  test("includes only used enum imports", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain("UserRoleSchema");
    expect(result).not.toContain("StatusSchema");
  });

  test("imports PrismaDecimal when Decimal field exists", () => {
    const result = generateModelSchema(mockProductModel, "effect-prisma/runtime");
    expect(result).toContain('import { PrismaDecimal } from "effect-prisma/runtime"');
  });

  test("skips PrismaDecimal when scalarMappings override Decimal", () => {
    const result = generateModelSchema(mockProductModel, "effect-prisma/runtime", {
      Decimal: "Schema.String",
    });
    expect(result).not.toContain("PrismaDecimal");
    expect(result).toContain("price: Schema.String");
  });

  test("does not import PrismaDecimal when no Decimal fields", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).not.toContain("PrismaDecimal");
  });

  test("handles optional fields with Schema.NullOr", () => {
    const result = generateModelSchema(mockUserModel, "effect-prisma/runtime");
    expect(result).toContain("Schema.NullOr(Schema.String)");
  });

  test("handles multiple enum imports", () => {
    const modelWithEnums = createMockModel("Test", [
      createMockField({ name: "role", kind: "enum", type: "UserRole" }),
      createMockField({ name: "status", kind: "enum", type: "Status" }),
    ]);
    const result = generateModelSchema(modelWithEnums, "effect-prisma/runtime");
    expect(result).toContain("UserRoleSchema");
    expect(result).toContain("StatusSchema");
  });
});

describe("generateSchemasIndex", () => {
  test("contains header comment", () => {
    const result = generateSchemasIndex([mockUserModel]);
    expect(result).toContain("// This file was generated by effect-prisma");
  });

  test("exports enums first", () => {
    const result = generateSchemasIndex([mockUserModel]);
    const enumsPos = result.indexOf("./enums.js");
    const userPos = result.indexOf("./user.js");
    expect(enumsPos).toBeLessThan(userPos);
  });

  test("exports models sorted alphabetically by snake_case", () => {
    const result = generateSchemasIndex([mockUserModel, mockPostModel]);
    const postPos = result.indexOf("./post.js");
    const userPos = result.indexOf("./user.js");
    expect(postPos).toBeLessThan(userPos);
  });

  test("exports all models", () => {
    const result = generateSchemasIndex([mockUserModel, mockPostModel, mockProductModel]);
    expect(result).toContain('export * from "./user.js"');
    expect(result).toContain('export * from "./post.js"');
    expect(result).toContain('export * from "./product.js"');
  });
});
